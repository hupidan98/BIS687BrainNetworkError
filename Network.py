from neuron import h, gui
from neuron.units import ms, mV
import Cell
import spikedelayer as sd

h.load_file("stdrun.hoc")
import numpy as np
import random

# cell_type is the cell(Cell.py) that are used to construct the neural network, position_info is a list of position of the cells, connection_mat is connection matrix generated by running methods from ConnectionMapGen.py. syn_mean_delay is the mean delay during cell synapses, syn_std_delay is the additional random delay following normal(syn_std_delay) distribution.
class Network():
    def __init__(
        self, cell_type = Cell.BallAndStick, position_info = None, connection_mat = None, 
        syn_mean_delay = 10, syn_std_delay = 0):
        """
        :param N: Number of cells.
        :param stim_w: Weight of the stimulus
        :param stim_t: time of the stimulus (in ms)
        :param stim_delay: delay of the stimulus (in ms)
        
        :param syn_w: Synaptic weight
        :param syn_delay: Delay of the synapse
        :param r: radius of the network
        """
        if connection_mat is not None:
            self._connection = connection_mat
        else:
            self._connection = cmg.RingMapGen(5, 0.1)
        
        self._syn_mean_delay = syn_mean_delay
        self._syn_std_delay = syn_std_delay
        
        self._create_cells(cell_type, position_info, connection_mat)
        # h.topology()
        self._connect_cells(connection_mat)
    
    
    def _create_cells(self, cell_type, position_info, connection_mat):
        self.cells = []
        if (position_info is not None):
            for i in range(len(position_info)):
                self.cells.append(cell_type(i, position_info[i]['x'], position_info[i]['y'], position_info[i]['z'], position_info[i]['theta']))
        else:
            N = self._connection.shape[0]
            r = N * 10
            for i in range(N):
                theta = i * 2 * h.PI / N
                self.cells.append(
                    cell_type(i, h.cos(theta) * r, h.sin(theta) * r, 0, theta)
                )
        
    def _connect_cells(self, connection_mat):
        for i in range(connection_mat.shape[0]):
            for j in range(connection_mat.shape[1]):
                if connection_mat[i, j] > 0:
                    source, target = self.cells[i], self.cells[j]

                    # nc = sd.NetCon(source.out, target.pos_syn)
                    nc = sd.NetCon(source.out._ref_v, target.pos_syn, sec=source.out_sec)
                    nc.weight[0] = connection_mat[i, j]
                    nc.mean_delay = self._syn_mean_delay * ms
                    nc.std_delay = self._syn_std_delay * ms
                    
                    # nc = h.NetCon(source.out._ref_v, target.pos_syn, sec=source.soma)
                    # nc.weight[0] = connection_mat[i, j]
                    # nc.delay = self._syn_mean_delay
                    
                    source._ncs.append(nc)
                elif connection_mat[i, j] < 0:
                    source, target = self.cells[i], self.cells[j]
                    
                    # nc = sd.NetCon(source.out, target.neg_syn)
                    nc = sd.NetCon(source.out._ref_v, target.neg_syn, sec=source.out_sec)
                    nc.weight[0] = -connection_mat[i, j]
                    nc.mean_delay = self._syn_mean_delay * ms
                    nc.std_delay = self._syn_std_delay * ms
                    
                    # nc = h.NetCon(source.out._ref_v, target.neg_syn, sec=source.soma)
                    # nc.weight[0] = -connection_mat[i, j]
                    # nc.delay = self._syn_mean_delay
                    
                    source._ncs.append(nc)
                        
        

    